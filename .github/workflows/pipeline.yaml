name: Pipeline EC2

on:
  push:
    branches:
      - 'prod'
      - 'dev'
  delete:
    branches:
      - 'feature**'

env:
  PIPELINE_USER_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
  PIPELINE_USER_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
  SAM_TEMPLATE: template.yaml
  TESTING_STACK_NAME: densenet-ec2-dev
  TESTING_PIPELINE_EXECUTION_ROLE: arn:aws:iam::471112837636:role/aws-sam-cli-managed-personal--PipelineExecutionRole-w1ceHg3Srqie
  TESTING_CLOUDFORMATION_EXECUTION_ROLE: arn:aws:iam::471112837636:role/aws-sam-cli-managed-perso-CloudFormationExecutionRo-LVTGVTJzrPve
  TESTING_ARTIFACTS_BUCKET: aws-sam-cli-managed-personal-accou-artifactsbucket-7twnozkcwdt3
  TESTING_APP_REPOSITORY: densenet121-app-dev
  TESTING_REGION: us-east-1
  PROD_STACK_NAME: densenet-ec2-prod
  PROD_PIPELINE_EXECUTION_ROLE: arn:aws:iam::471112837636:user/aws-sam-cli-managed-personal-account-d-PipelineUser-0c4EBLF4Lx9H
  PROD_CLOUDFORMATION_EXECUTION_ROLE: arn:aws:iam::471112837636:role/aws-sam-cli-managed-personal--PipelineExecutionRole-w1ceHg3Srqie
  PROD_ARTIFACTS_BUCKET: aws-sam-cli-managed-personal-accou-artifactsbucket-lvukcyulkbfh
  PROD_APP_REPOSITORY: densenet121-app-prod
  PROD_REGION: us-east-1
  TEST_DATA_BUCKET: densenet-test-data-${{ github.ref == 'refs/heads/prod' && 'prod' || 'dev' }}
  STAGE: ${{ github.ref == 'refs/heads/prod' && 'prod' || 'dev' }}
  MODEL_REPOSITORY: densenet121-model-${{ github.ref == 'refs/heads/prod' && 'prod' || 'dev' }}

jobs:
  test:
    if: github.event_name == 'push'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install test dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r tests/requirements-test.txt
          pip install docker boto3 requests Pillow numpy onnxruntime
          
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.PIPELINE_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.PIPELINE_USER_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.TESTING_REGION }}
          role-to-assume: ${{ env.TESTING_PIPELINE_EXECUTION_ROLE }}
          role-session-name: testing-session
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Setup test data bucket
        run: |
          python -c "
          import boto3
          import time
          s3 = boto3.client('s3')
          bucket_name = '${{ env.TEST_DATA_BUCKET }}'
          
          try:
              s3.head_bucket(Bucket=bucket_name)
              print(f'Bucket {bucket_name} ya existe')
          except:
              if '${{ env.TESTING_REGION }}' == 'us-east-1':
                  s3.create_bucket(Bucket=bucket_name)
              else:
                  s3.create_bucket(
                      Bucket=bucket_name,
                      CreateBucketConfiguration={'LocationConstraint': '${{ env.TESTING_REGION }}'}
                  )
              print(f'Bucket {bucket_name} creado')
              time.sleep(5)
          "

      - name: Generate and upload test data
        env:
          AWS_REGION: ${{ env.TESTING_REGION }}
          STAGE: ${{ env.STAGE }}
          TEST_DATA_BUCKET: ${{ env.TEST_DATA_BUCKET }}
        run: |
          python scripts/generate_test_data.py
          
      - name: Install Docker
        run: |
          sudo apt-get update
          sudo apt-get install -y ca-certificates curl gnupg
          sudo install -m 0755 -d /etc/apt/keyrings
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
          sudo chmod a+r /etc/apt/keyrings/docker.gpg
          echo \
            "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \
            $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
            sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
          sudo apt-get update
          sudo apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
          sudo systemctl start docker || true
          sudo systemctl status docker
          sudo usermod -aG docker $USER
          docker --version

      - name: Download model from ECR for tests
        env:
          AWS_REGION: ${{ env.TESTING_REGION }}
          STAGE: ${{ env.STAGE }}
          AWS_ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          MODEL_REPOSITORY: ${{ env.MODEL_REPOSITORY }}
        run: |
          sudo mkdir -p /tmp
          sudo chmod 777 /tmp
          echo "Descargando modelo desde ECR para tests..."
          python scripts/download_model.py
          if [ ! -f "/tmp/densenet121_Opset17.onnx" ]; then
            echo "Error: El modelo no se descarg√≥ correctamente"
            exit 1
          fi
          echo "Modelo descargado exitosamente para tests"
          ls -l /tmp/densenet121_Opset17.onnx

      - name: Run tests
        env:
          AWS_REGION: ${{ env.TESTING_REGION }}
          STAGE: ${{ env.STAGE }}
          TEST_DATA_BUCKET: ${{ env.TEST_DATA_BUCKET }}
        run: |
          if [ ! -f "/tmp/densenet121_Opset17.onnx" ]; then
            echo "Error: El modelo no existe en /tmp"
            ls -la /tmp
            exit 1
          fi
          pytest tests/test_model.py -v

  build-and-deploy-dev:
    if: github.ref == 'refs/heads/dev'
    needs: [test]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install docker boto3 requests Pillow numpy onnxruntime

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.PIPELINE_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.PIPELINE_USER_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.TESTING_REGION }}
          role-to-assume: ${{ env.TESTING_PIPELINE_EXECUTION_ROLE }}
          role-session-name: dev-deployment
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Check and create application ECR repository if needed
        env:
          AWS_REGION: ${{ env.TESTING_REGION }}
          REPOSITORY_NAME: ${{ env.TESTING_APP_REPOSITORY }}
        run: |
          echo "Verificando si el repositorio ECR existe..."
          if aws ecr describe-repositories --repository-names $REPOSITORY_NAME --region $AWS_REGION 2>/dev/null; then
            echo "‚úÖ Repositorio ECR ya existe: $REPOSITORY_NAME"
            echo "ECR_REPO_EXISTS=true" >> $GITHUB_ENV
          else
            echo "üì¶ Creando repositorio ECR para la aplicaci√≥n..."
            aws ecr create-repository \
              --repository-name $REPOSITORY_NAME \
              --region $AWS_REGION \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability MUTABLE
            echo "‚úÖ Repositorio ECR creado: $REPOSITORY_NAME"
            echo "ECR_REPO_EXISTS=false" >> $GITHUB_ENV
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push application image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.TESTING_APP_REPOSITORY }}
          IMAGE_TAG: latest
          ACCOUNT_ID: ${{ env.AWS_ACCOUNT_ID }}
          AWS_REGION: ${{ env.TESTING_REGION }}
        run: |
          cd ec2_app
          
          # Verificar que tenemos los archivos necesarios
          if [ ! -f "Dockerfile" ]; then
            echo "Error: Dockerfile no encontrado en ec2_app/"
            exit 1
          fi
          
          echo "Construyendo imagen Docker para EC2..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          
          echo "Subiendo imagen a ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          echo "‚úÖ Imagen de aplicaci√≥n construida y subida exitosamente"
          echo "Imagen: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      - uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - name: Deploy to dev
        env:
          INSTANCE_TYPE: t3.medium
        run: |
          echo "Desplegando infraestructura EC2 a entorno dev..."
          
          # Determinar si necesitamos crear el repositorio ECR en CloudFormation
          CREATE_ECR_REPO="false"
          if [ "${{ env.ECR_REPO_EXISTS }}" = "false" ]; then
            CREATE_ECR_REPO="true"
            echo "Configurando CloudFormation para crear repositorio ECR"
          else
            echo "Usando repositorio ECR existente"
          fi
          
          sam deploy \
            --stack-name ${TESTING_STACK_NAME} \
            --template-file ${SAM_TEMPLATE} \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --region ${TESTING_REGION} \
            --s3-bucket ${TESTING_ARTIFACTS_BUCKET} \
            --no-fail-on-empty-changeset \
            --role-arn ${TESTING_CLOUDFORMATION_EXECUTION_ROLE} \
            --parameter-overrides \
              Stage=dev \
              InstanceType=${INSTANCE_TYPE} \
              CreateECRRepo=${CREATE_ECR_REPO} \
            --debug

      - name: Wait for deployment and verify
        env:
          STACK_NAME: ${{ env.TESTING_STACK_NAME }}
          AWS_REGION: ${{ env.TESTING_REGION }}
        run: |
          echo "Esperando a que el deployment complete..."
          aws cloudformation wait stack-update-complete \
            --stack-name ${STACK_NAME} \
            --region ${AWS_REGION} || \
          aws cloudformation wait stack-create-complete \
            --stack-name ${STACK_NAME} \
            --region ${AWS_REGION}
          
          echo "Obteniendo URL de la aplicaci√≥n..."
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --region ${AWS_REGION} \
            --query 'Stacks[0].Outputs[?OutputKey==`DenseNetApiUrl`].OutputValue' \
            --output text)
          
          echo "API URL: $API_URL"
          
          # Esperar a que la aplicaci√≥n est√© lista
          echo "Esperando a que la aplicaci√≥n est√© disponible..."
          for i in {1..20}; do
            if curl -f -m 10 "$API_URL/health" 2>/dev/null; then
              echo "‚úÖ Aplicaci√≥n respondiendo correctamente"
              break
            fi
            echo "Esperando... intento $i/20"
            sleep 30
          done
          
          # Verificar endpoint de documentaci√≥n
          echo "Verificando endpoint de documentaci√≥n..."
          curl -f -m 10 "$API_URL/docs" || echo "‚ö†Ô∏è Docs endpoint no responde, pero la aplicaci√≥n est√° funcionando"

      - name: Trigger application restart on instances
        env:
          STACK_NAME: ${{ env.TESTING_STACK_NAME }}
          AWS_REGION: ${{ env.TESTING_REGION }}
        run: |
          echo "Reiniciando aplicaci√≥n en instancias EC2..."
          
          # Obtener el nombre del Auto Scaling Group
          ASG_NAME=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --region ${AWS_REGION} \
            --query 'Stacks[0].Outputs[?OutputKey==`AutoScalingGroupName`].OutputValue' \
            --output text)
          
          if [ ! -z "$ASG_NAME" ]; then
            echo "Auto Scaling Group: $ASG_NAME"
            
            # Obtener instancias del ASG
            INSTANCE_IDS=$(aws autoscaling describe-auto-scaling-groups \
              --auto-scaling-group-names $ASG_NAME \
              --region ${AWS_REGION} \
              --query 'AutoScalingGroups[0].Instances[?LifecycleState==`InService`].InstanceId' \
              --output text)
            
            if [ ! -z "$INSTANCE_IDS" ]; then
              echo "Instancias encontradas: $INSTANCE_IDS"
              
              # Ejecutar comando de reinicio en cada instancia
              for INSTANCE_ID in $INSTANCE_IDS; do
                echo "Reiniciando aplicaci√≥n en instancia: $INSTANCE_ID"
                aws ssm send-command \
                  --region ${AWS_REGION} \
                  --document-name "AWS-RunShellScript" \
                  --targets "Key=instanceids,Values=$INSTANCE_ID" \
                  --parameters 'commands=["sudo systemctl restart densenet-app", "sleep 30", "/home/ec2-user/health-check.sh"]' \
                  --comment "Restart DenseNet application after deployment" \
                  --timeout-seconds 300 || echo "‚ö†Ô∏è No se pudo enviar comando SSM a $INSTANCE_ID"
              done
            else
              echo "No se encontraron instancias en servicio"
            fi
          else
            echo "No se pudo obtener el nombre del Auto Scaling Group"
          fi

  build-and-deploy-prod:
    if: github.ref == 'refs/heads/prod'
    needs: [test]
    runs-on: ubuntu-latest
    environment: production  # Requiere aprobaci√≥n manual
    steps:
      - uses: actions/checkout@v3
      
      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
          
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install docker boto3 requests Pillow numpy onnxruntime

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ env.PIPELINE_USER_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ env.PIPELINE_USER_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.PROD_REGION }}
          role-to-assume: ${{ env.PROD_PIPELINE_EXECUTION_ROLE }}
          role-session-name: prod-deployment
          role-duration-seconds: 3600
          role-skip-session-tagging: true

      - name: Check and create application ECR repository if needed
        env:
          AWS_REGION: ${{ env.PROD_REGION }}
          REPOSITORY_NAME: ${{ env.PROD_APP_REPOSITORY }}
        run: |
          echo "Verificando si el repositorio ECR existe..."
          if aws ecr describe-repositories --repository-names $REPOSITORY_NAME --region $AWS_REGION 2>/dev/null; then
            echo "‚úÖ Repositorio ECR ya existe: $REPOSITORY_NAME"
            echo "ECR_REPO_EXISTS=true" >> $GITHUB_ENV
          else
            echo "üì¶ Creando repositorio ECR para la aplicaci√≥n..."
            aws ecr create-repository \
              --repository-name $REPOSITORY_NAME \
              --region $AWS_REGION \
              --image-scanning-configuration scanOnPush=true \
              --image-tag-mutability MUTABLE
            echo "‚úÖ Repositorio ECR creado: $REPOSITORY_NAME"
            echo "ECR_REPO_EXISTS=false" >> $GITHUB_ENV
          fi

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push application image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: ${{ env.PROD_APP_REPOSITORY }}
          IMAGE_TAG: latest
        run: |
          cd ec2_app
          echo "Construyendo imagen Docker para producci√≥n..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          echo "Subiendo imagen a ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "‚úÖ Imagen de aplicaci√≥n construida y subida exitosamente"

      - uses: aws-actions/setup-sam@v2
        with:
          use-installer: true

      - name: Deploy to production
        env:
          INSTANCE_TYPE: t3.large
        run: |
          echo "Desplegando infraestructura EC2 a entorno prod..."
          
          # Determinar si necesitamos crear el repositorio ECR en CloudFormation
          CREATE_ECR_REPO="false"
          if [ "${{ env.ECR_REPO_EXISTS }}" = "false" ]; then
            CREATE_ECR_REPO="true"
            echo "Configurando CloudFormation para crear repositorio ECR"
          else
            echo "Usando repositorio ECR existente"
          fi
          
          sam deploy \
            --stack-name ${PROD_STACK_NAME} \
            --template-file ${SAM_TEMPLATE} \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --region ${PROD_REGION} \
            --s3-bucket ${PROD_ARTIFACTS_BUCKET} \
            --no-fail-on-empty-changeset \
            --role-arn ${PROD_CLOUDFORMATION_EXECUTION_ROLE} \
            --parameter-overrides \
              Stage=prod \
              InstanceType=${INSTANCE_TYPE} \
              CreateECRRepo=${CREATE_ECR_REPO} \
            --debug

      - name: Verify production deployment
        env:
          STACK_NAME: ${{ env.PROD_STACK_NAME }}
          AWS_REGION: ${{ env.PROD_REGION }}
        run: |
          echo "Verificando deployment en producci√≥n..."
          aws cloudformation wait stack-update-complete \
            --stack-name ${STACK_NAME} \
            --region ${AWS_REGION} || \
          aws cloudformation wait stack-create-complete \
            --stack-name ${STACK_NAME} \
            --region ${AWS_REGION}
          
          API_URL=$(aws cloudformation describe-stacks \
            --stack-name ${STACK_NAME} \
            --region ${AWS_REGION} \
            --query 'Stacks[0].Outputs[?OutputKey==`DenseNetApiUrl`].OutputValue' \
            --output text)
          
          echo "Production API URL: $API_URL"
          
          # Esperar y verificar que la aplicaci√≥n est√© funcionando
          echo "Verificando que la aplicaci√≥n est√© funcionando..."
          for i in {1..20}; do
            if curl -f -m 10 "$API_URL/health" 2>/dev/null; then
              echo "‚úÖ Aplicaci√≥n en producci√≥n respondiendo correctamente"
              break
            fi
            echo "Esperando... intento $i/20"
            sleep 30
          done